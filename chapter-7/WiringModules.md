# Chapter 7. Wiring Modules

Node.js 的模块系统极大填充了 JavaScript 语言中的断层：缺乏原生的方式来把代码组织到独立的单元中。一个最大的优点就是使用 require 函数把模块组织到一起，简单有力。但是许多 Node.js 新手还是会问：用哪种方式是把组件 X 的实例传入模块 Y 中最好。

有时这种混乱导致在希望找到一种更熟悉的方式将我们的模块链接在一起时对单例模式绝望的追求。换句话说，这可能会过度随意使用依赖注入模式导入任何类型的依赖。模块的写法在 Node.js 中是最具有争议和主观性的话题。有许多思想流派影响着这个领域，但没有一个可以被视为拥有无可争议的真理。每一种实现都有其优缺点并且他们经常最终在同一个应用程序中混合在一起，改编，定制或以其他名称伪装使用。

在本章，我们将分析各种把模块连接起来的实现。并比较它们的优缺点进而帮助我们在简约性、可重用性、拓展性方面进行权衡。

总的来说，我们将展示关于这个主题的几种最重要的模式：

* 硬编码依赖
* 依赖注入
* 服务定位器
* 依赖注入容器

然后我们将探讨一个密切相关的问题，即如何连接插件。这是在连接模块时经常遇到的问题，它们呈现出相同的特征，但是依据的应用上下文略有差异，特别是在一个插件被当作 Node.js 包来发布时。我们将学习创建一个插件化的架构然后聚焦如何把这些插件集成进主要应用的流程内。

本章结尾，令人摸不着头脑的模块连接问题将不再困惑我们。

## 模块和依赖

每一个现代化的应用总结起来就是一些模块的聚合产物，因为随着应用的增长，我们连接这些组件的方式变得异常重要。这不仅仅关系到技术方面，例如拓展性，而且也关系到整个系统的运行。纠结的依赖图是一种负担，它增加了项目的技术债；与此同时，任何代码的改变无论是修改或者拓展都将导致极大的副作用。

最糟糕的是，组件紧密地连接在一起，最后我们只能重构或完全重写这一部分。当然，这并不意味着我们必须从第一个模块就开始过度设计我们的设计，但从一开始就找到一个很好的平衡将产生深远的影响。

Node.js 提供了一个伟大的工具来组织连接模块。它就是 CommonJS 模块系统。但是单独的模块系统无法保证成功；换句话说，它虽然为客户端和依赖间提供了便利，如果使用不当，它可能会引入更紧密的耦合。在这部分，我们将讨论一些 Node.js 中的基本方面。

### Node.js 中最普遍的依赖

在软件架构中，我们称任何影响组件行为或结构的实体、状态，或者数据格式为依赖。例如，一个组件可能使用了另一个组件的服务，依托特定的系统全局状态或者实现一种特定的交流协议来与其它组件交流信息等等情况。依赖的概念非常广泛而且很难被界定。

但是，在 Node.js 中，我们可以立即识别出一种基本的依赖类型，这是最常见且易于识别的; 当然，我们正在讨论模块之间的依赖关系。模块是我们处理和组织代码结构的基本机制；在不依赖模块系统的情况下构建大型应用程序是不合理的。如果恰当的把各类元素组合在一起，将带来巨大的好处。实际上，模块的属性可以这样总结：

* 一个模块更加可读且便于理解，理想情况下它的内举行更高
* 以单一文件呈现，模块易于区分
* 模块可以在不同的应用间重用

模块呈现了信息隐藏的完美粒度级别，而且是仅提供公开组件的公共接口的有效机制（使用 module.exports）。

但是，仅仅通过应用或者库的功能来简单分割模块还远远算不上成功的设计。其中一个谬误将在我们的删除或替换模块时被终结。我们迅速认识到把代码组织进模块内并把它们连接起来将非常重要。同时，就像软件设计中的其它问题一样，在不同的标准间找到平衡才是关键。

### 内聚和耦合

在构建模块时最重要的两点属性就是内聚和耦合。它们可以被运用到软件架构中的任意组件或子系统，所以我们把这两点作为构建 Node.js 模块时的指导方针。

* 内聚：衡量一个组件中功能间的相关性。例如，一个模块只做一件事，这就体现出了这个模块的搞内聚性。一个包含好几种保存对象到数据库的功能 -- saveProduct()、saveInvoice()、saveUser()，它的内聚性就很低。
* 耦合：衡量一个模块依赖多少个其它模块。例如，当一个模块直接从另一个模块内读取数据时，我们说耦合很高。当然，如果两个模块通过全局或共享状态也是耦合很高。换句话说，两个模块只通过传递参数来交流的话就是松耦合。

我们的目标是高内聚与松耦合，这样的模块会更易读，可用性更高也更容易拓展。

### 有状态的模块

在 JavaScript 中，一切都是对象。我们没有像纯接口或这类的抽象概念；它的动态类型已经提供了一种将接口（或策略）与实现（或细节）分离的自然机制。

在 JavaScript 中，我们在将接口与实现分离时遇到是最小的问题；但是，通过简单使用 Node.js 模块系统，我们已经引入了一种硬编码的特殊实现。一般情况下，这没有问题，但是如果我们使用 require 来导入一个暴露状态化实例的模块时，例如像 db 处理、HTTP 服务实例、服务实例、或者是任何无状态的对象，实际上我们都是引用了一个类似单例的东西，因此继承了它的优点和缺点，并增加了一些注意事项。

#### Node.js 中的单例模式

很多 Node.js 新手对于如何在 Node.js 中正确实现单例充满困惑，大部分时间都是为了在应用程序的各个模块之间共享实例。但是，答案比我们想象的简单；使用 module.exports 简单导出一个实例就已经足够拥有一个类似于单例的东西了。

````JavaScript
// 'db.js' module

module.exports = new Database('my-app-db')
````

通过简单导出一个数据库实例，我们已经获取了 db 模块的实例了。因为 Node.js 会在第一次调用 require 方法后缓存模块，并在后面的调用中直接返回这个模块的缓存。例如，我们简单拥有一个 db 共享的实例：

````JavaScript
const db = require('./db')
````

这里需要注意的点是，模块以它的全路径作为键被缓存，因此这里单例只是当前的包的单例。

````JavaScript
//package.json
{
  "name": "mydb",
  "main": "db.js"
}

// file structure
app/
`-- node_modules
    |-- packageA
    |  `-- node_modules
    |      `-- mydb
    `-- packageB
        `-- node_modules
            `-- mydb

````

packageA 和 packageB 都依赖于 mydb 包；app 包依赖于 packageA 和 packageB。但是 packageA 和 packageB 包都将导入各自的 mydb 模块，因为它们的路径是不同的。

从这点来说，我们字面上描述的单例并不存在于 Node.js 中，除非我们使用一个真正的全局变量来保存它：


````JavaScript
global.db = new Database('my-app-db')
````

这将保证实例在整个应用内是唯一且共享，而不像是个包一样根据导入路径而无法保持状态。大多数情况下，我们不需要一个真正的单例，如果真的需要，我们将在后面看到另一个模式来在不同的包之间共享一个实例。
